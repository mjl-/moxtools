// NOTE: GENERATED by github.com/mjl-/sherpats, DO NOT MODIFY

namespace api {

export interface SPFReceived {
	Status: string
	Mechanism: string
}

// Domain is a domain name, with one or more labels, with at least an ASCII
// representation, and for IDNA non-ASCII domains a unicode representation.
// The ASCII string must be used for DNS lookups. The strings do not have a
// trailing dot. When using with StrictResolver, add the trailing dot.
export interface Domain {
	ASCII: string  // A non-unicode domain, e.g. with A-labels (xn--...) or NR-LDH (non-reserved letters/digits/hyphens) labels. Always in lower case. No trailing dot.
	Unicode: string  // Name as U-labels. Empty if this is an ASCII-only domain. No trailing dot.
}

// Record is a DKIM DNS record, served on <selector>._domainkey.<domain> for a
// given selector and domain (s= and d= in the DKIM-Signature).
// 
// The record is a semicolon-separated list of "="-separated field value pairs.
// Strings should be compared case-insensitively, e.g. k=ed25519 is equivalent to k=ED25519.
// 
// Example:
// 
// 	v=DKIM1;h=sha256;k=ed25519;p=ln5zd/JEX4Jy60WAhUOv33IYm2YZMyTQAdr9stML504=
export interface Record {
	Version: string  // Version, fixed "DKIM1" (case sensitive). Field "v".
	Hashes?: string[] | null  // Acceptable hash algorithms, e.g. "sha1", "sha256". Optional, defaults to all algorithms. Field "h".
	Key: string  // Key type, "rsa" or "ed25519". Optional, default "rsa". Field "k".
	Notes: string  // Debug notes. Field "n".
	Pubkey?: string | null  // Public key, as base64 in record. If empty, the key has been revoked. Field "p".
	Services?: string[] | null  // Service types. Optional, default "*" for all services. Other values: "email". Field "s".
	Flags?: string[] | null  // Flags, colon-separated. Optional, default is no flags. Other values: "y" for testing DKIM, "s" for "i=" must have same domain as "d" in signatures. Field "t".
}

export interface DKIMResult {
	Status: DKIMStatus
	Sig?: Sig | null  // Parsed form of DKIM-Signature header. Can be nil for invalid DKIM-Signature header.
	Record?: Record | null  // Parsed form of DKIM DNS record for selector and domain in Sig. Optional.
	RecordAuthentic: boolean  // Whether DKIM DNS record was DNSSEC-protected. Only valid if Sig is non-nil.
	Error: string  // If Status is not StatusPass, this error holds the details and can be checked using errors.Is.
}

// Sig is a DKIM-Signature header.
// 
// String values must be compared case insensitively.
export interface Sig {
	Version: number  // Required fields.; Version, 1. Field "v". Always the first field.
	AlgorithmSign: string  // "rsa" or "ed25519". Field "a".
	AlgorithmHash: string  // "sha256" or the deprecated "sha1" (deprecated). Field "a".
	Signature?: string | null  // Field "b".
	BodyHash?: string | null  // Field "bh".
	Domain: Domain  // Field "d".
	SignedHeaders?: string[] | null  // Duplicates are meaningful. Field "h".
	Selector: Domain  // Selector, for looking DNS TXT record at <s>._domainkey.<domain>. Field "s".
	Canonicalization: string  // Optional fields. Canonicalization is the transformation of header and/or body before hashing. The value is in original case, but must be compared case-insensitively. Normally two slash-separated values: header canonicalization and body canonicalization. But the "simple" means "simple/simple" and "relaxed" means "relaxed/simple". Field "c".
	Length: number  // Body length to verify, default -1 for whole body. Field "l".
	Identity?: Identity | null  // AUID (agent/user id). If nil and an identity is needed, should be treated as an Identity without localpart and Domain from d= field. Field "i".
	QueryMethods?: string[] | null  // For public key, currently known value is "dns/txt" (should be compared case-insensitively). If empty, dns/txt must be assumed. Field "q".
	SignTime: number  // Unix epoch. -1 if unset. Field "t".
	ExpireTime: number  // Unix epoch. -1 if unset. Field "x".
	CopiedHeaders?: string[] | null  // Copied header fields. Field "z".
}

// Identity is used for the optional i= field in a DKIM-Signature header. It uses
// the syntax of an email address, but does not necessarily represent one.
export interface Identity {
	Localpart?: Localpart | null  // Optional.
	Domain: Domain
}

export interface DomainResult {
	DurationMS: number
	Domain: Domain
	SPF: DomainSPF
	DMARC: DomainDMARC
	TLSRPT: DomainTLSRPT
	MTASTS: DomainMTASTS
	MX: DomainMX
	MXHosts?: DomainMXHost[] | null
}

export interface DomainSPF {
	DurationMS: number
	Status: string
	TXT: string
	Record?: SPFRecord | null
	Authentic: boolean
	Error: string
}

export interface SPFRecord {
	Version: string  // Must be "spf1".
	Directives?: Directive[] | null  // An IP is evaluated against each directive until a match is found.
	Redirect: string  // Modifier that redirects SPF checks to other domain after directives did not match. Optional. For "redirect=".
	Explanation: string  // Modifier for creating a user-friendly error message when an IP results in status "fail".
	Other?: Modifier[] | null  // Other modifiers.
}

// Directive consists of a mechanism that describes how to check if an IP matches,
// an (optional) qualifier indicating the policy for a match, and optional
// parameters specific to the mechanism.
export interface Directive {
	Qualifier: string  // Sets the result if this directive matches. "" and "+" are "pass", "-" is "fail", "?" is "neutral", "~" is "softfail".
	Mechanism: string  // "all", "include", "a", "mx", "ptr", "ip4", "ip6", "exists".
	DomainSpec: string  // For include, a, mx, ptr, exists. Always in lower-case when parsed using ParseRecord.
	IPstr: string  // Original string for IP, always with /subnet.
	IP4CIDRLen?: number | null  // For a, mx, ip4.
	IP6CIDRLen?: number | null  // For a, mx, ip6.
}

// Modifier provides additional information for a policy.
// "redirect" and "exp" are not represented as a Modifier but explicitly in a Record.
export interface Modifier {
	Key: string  // Key is case-insensitive.
	Value: string
}

export interface DomainDMARC {
	DurationMS: number
	Status: string
	Domain: Domain
	Record?: DMARCRecord | null
	TXT: string
	Authentic: boolean
	Error: string
}

export interface DMARCRecord {
	Version: string  // "v=DMARC1", fixed.
	Policy: DMARCPolicy  // Required, for "p=".
	SubdomainPolicy: DMARCPolicy  // Like policy but for subdomains. Optional, for "sp=".
	AggregateReportAddresses?: URI[] | null  // Optional, for "rua=". Destination addresses for aggregate reports.
	FailureReportAddresses?: URI[] | null  // Optional, for "ruf=". Destination addresses for failure reports.
	ADKIM: Align  // Alignment: "r" (default) for relaxed or "s" for simple. For "adkim=".
	ASPF: Align  // Alignment: "r" (default) for relaxed or "s" for simple. For "aspf=".
	AggregateReportingInterval: number  // In seconds, default 86400. For "ri="
	FailureReportingOptions?: string[] | null  // "0" (default), "1", "d", "s". For "fo=".
	ReportingFormat?: string[] | null  // "afrf" (default). For "rf=".
	Percentage: number  // Between 0 and 100, default 100. For "pct=". Policy applies randomly to this percentage of messages.
}

// URI is a destination address for reporting.
export interface URI {
	Address: string  // Should start with "mailto:".
	MaxSize: number  // Optional maximum message size, subject to Unit.
	Unit: string  // "" (b), "k", "m", "g", "t" (case insensitive), unit size, where k is 2^10 etc.
}

export interface DomainTLSRPT {
	DurationMS: number
	Record?: TLSRPTRecord | null
	TXT: string
	Error: string
}

export interface TLSRPTRecord {
	Version: string  // "TLSRPTv1", for "v=".
	RUAs?: (RUA[] | null)[] | null  // Aggregate reporting URI, for "rua=". "rua=" can occur multiple times, each can be a list.
	Extensions?: Extension[] | null
}

// Extension is an additional key/value pair for a TLSRPT record.
export interface Extension {
	Key: string
	Value: string
}

export interface DomainMTASTS {
	DurationMS: number
	Implemented: boolean
	Record?: MTASTSRecord | null
	Policy?: Policy | null
	PolicyText: string
	Error: string
}

export interface MTASTSRecord {
	Version: string  // "STSv1", for "v=". Required.
	ID: string  // Record version, for "id=". Required.
	Extensions?: Pair[] | null  // Optional extensions.
}

// Pair is an extension key/value pair in a MTA-STS DNS record or policy.
export interface Pair {
	Key: string
	Value: string
}

// Policy is an MTA-STS policy as served at "https://mta-sts.<domain>/.well-known/mta-sts.txt".
export interface Policy {
	Version: string  // "STSv1"
	Mode: Mode
	MX?: STSMX[] | null
	MaxAgeSeconds: number  // How long this policy can be cached. Suggested values are in weeks or more.
	Extensions?: Pair[] | null
}

// STSMX is an allowlisted MX host name/pattern.
// todo: find a way to name this just STSMX without getting duplicate names for "MX" in the sherpa api.
export interface STSMX {
	Wildcard: boolean  // "*." wildcard, e.g. if a subdomain matches. A wildcard must match exactly one label. *.example.com matches mail.example.com, but not example.com, and not foor.bar.example.com.
	Domain: Domain
}

export interface DomainMX {
	DurationMS: number
	Have: boolean
	OrigNextHopAuthentic: boolean
	ExpandedNextHopAuthentic: boolean
	ExpandedNextHop: Domain
	Permanent: boolean
	Error: string
}

export interface DomainMXHost {
	DurationMS: number
	Host: IPDomain
	MTASTSError: string
	IP: DomainIP
	DANE: DomainDANE
	Dial: DomainDial
	SMTP: DomainSMTP
}

// IPDomain is an ip address, a domain, or empty.
export interface IPDomain {
	IP: IP
	Domain: Domain
}

export interface DomainIP {
	DurationMS: number
	Authentic: boolean
	ExpandedAuthentic: boolean
	ExpandedHost: Domain
	IPs?: IP[] | null
	DualStack: boolean
	Error: string
}

export interface DomainDANE {
	DurationMS: number
	Required: boolean
	Records?: TLSARecord[] | null
	TLSABaseDomain: Domain
	Error: string
	VerifiedRecord: TLSARecord
}

export interface TLSARecord {
	Usage: TLSAUsage  // Which validations must be performed.
	Selector: TLSASelector  // What needs to be validated (full certificate or only public key).
	MatchType: TLSAMatchType  // In which form the certificate/public key is stored in CertAssoc.
	CertAssoc?: string | null  // Certificate association data.
}

export interface DomainDial {
	DurationMS: number
	IP: IP
	Error: string
}

export interface DomainSMTP {
	DurationMS: number
	Error: string
	Supports8bitMIME: boolean
	SupportsRequireTLS: boolean
	SupportsSMTPUTF8: boolean
	SupportsSTARTTLS: boolean
	TLSConnectionState?: TLSConnectionState | null
	RecipientDomainResult?: TLSRPTResult | null
	HostResult?: TLSRPTResult | null
	Trace?: Proto[] | null
}

export interface TLSConnectionState {
	Version: string
	CipherSuite: string
	NegotiatedProtocol: string
	ServerName: string
}

export interface TLSRPTResult {
	Policy: TLSRPTResultPolicy
	Summary: TLSRPTSummary
	FailureDetails?: TLSRPTFailureDetails[] | null
}

export interface TLSRPTResultPolicy {
	Type: string
	String?: string[] | null
	Domain: string
	MXHost?: string[] | null
}

export interface TLSRPTSummary {
	TotalSuccessfulSessionCount: number
	TotalFailureSessionCount: number
}

export interface TLSRPTFailureDetails {
	ResultType: string
	SendingMTAIP: string
	ReceivingMXHostname: string
	ReceivingMXHelo: string
	ReceivingIP: string
	FailedSessionCount: number
	AdditionalInformation: string
	FailureReasonCode: string
}

export interface Proto {
	ClientWrite: boolean
	Text: string
}

// TLSAUsage indicates which certificate/public key verification must be done.
export enum TLSAUsage {
	// PKIX/WebPKI, certificate must be valid (name, expiry, signed by CA, etc) and
	// signed by the trusted-anchor (TA) in this record.
	TLSAUsagePKIXTA = 0,
	// PKIX/WebPKI, certificate must be valid (name, expiry, signed by CA, etc) and
	// match the certificate in the record.
	TLSAUsagePKIXEE = 1,
	// Certificate must be signed by trusted-anchor referenced in record, with matching
	// name, non-expired, etc.
	TLSAUsageDANETA = 2,
	// Certificate must match the record. No further requirements on name, expiration
	// or who signed it.
	TLSAUsageDANEEE = 3,
}

// TLSASelecter indicates the data the "certificate association" field is based on.
export enum TLSASelector {
	TLSASelectorCert = 0,  // DER-encoded x509 certificate.
	TLSASelectorSPKI = 1,  // DER-encoded subject public key info (SPKI), so only the public key and its type.
}

// TLSAMatchType indicates in which form the data as indicated by the selector
// is stored in the record as certificate association.
export enum TLSAMatchType {
	TLSAMatchTypeFull = 0,  // Full data, e.g. a full DER-encoded SPKI or even certificate.
	TLSAMatchTypeSHA256 = 1,  // SHA2-256-hashed data, either SPKI or certificate.
	TLSAMatchTypeSHA512 = 2,  // SHA2-512-hashed data.
}

export type DKIMStatus = string

// Localpart is a decoded local part of an email address, before the "@".
// For quoted strings, values do not hold the double quote or escaping backslashes.
// An empty string can be a valid localpart.
export type Localpart = string

// Policy as used in DMARC DNS record for "p=" or "sp=".
export enum DMARCPolicy {
	PolicyEmpty = "",  // Only for the optional Record.SubdomainPolicy.
	PolicyNone = "none",
	PolicyQuarantine = "quarantine",
	PolicyReject = "reject",
}

// Align specifies the required alignment of a domain name.
export enum Align {
	AlignStrict = "s",  // Strict requires an exact domain name match.
	AlignRelaxed = "r",  // Relaxed requires either an exact or subdomain name match.
}

// RUA is a reporting address with scheme and special characters ",", "!" and
// ";" not encoded.
export type RUA = string

// Mode indicates how the policy should be interpreted.
export enum Mode {
	ModeEnforce = "enforce",  // Policy must be followed, i.e. deliveries must fail if a TLS connection cannot be made.
	ModeTesting = "testing",  // In case TLS cannot be negotiated, plain SMTP can be used, but failures must be reported, e.g. with TLSRPT.
	ModeNone = "none",  // In case MTA-STS is not or no longer implemented.
}

// An IP is a single IP address, a slice of bytes.
// Functions in this package accept either 4-byte (IPv4)
// or 16-byte (IPv6) slices as input.
// 
// Note that in this documentation, referring to an
// IP address as an IPv4 address or an IPv6 address
// is a semantic property of the address, not just the
// length of the byte slice: a 16-byte slice can still
// be an IPv4 address.
export type IP = string

export const structTypes: {[typename: string]: boolean} = {"DKIMResult":true,"DMARCRecord":true,"Directive":true,"Domain":true,"DomainDANE":true,"DomainDMARC":true,"DomainDial":true,"DomainIP":true,"DomainMTASTS":true,"DomainMX":true,"DomainMXHost":true,"DomainResult":true,"DomainSMTP":true,"DomainSPF":true,"DomainTLSRPT":true,"Extension":true,"IPDomain":true,"Identity":true,"MTASTSRecord":true,"Modifier":true,"Pair":true,"Policy":true,"Proto":true,"Record":true,"SPFReceived":true,"SPFRecord":true,"STSMX":true,"Sig":true,"TLSARecord":true,"TLSConnectionState":true,"TLSRPTFailureDetails":true,"TLSRPTRecord":true,"TLSRPTResult":true,"TLSRPTResultPolicy":true,"TLSRPTSummary":true,"URI":true}
export const stringsTypes: {[typename: string]: boolean} = {"Align":true,"DKIMStatus":true,"DMARCPolicy":true,"IP":true,"Localpart":true,"Mode":true,"RUA":true}
export const intsTypes: {[typename: string]: boolean} = {"TLSAMatchType":true,"TLSASelector":true,"TLSAUsage":true}
export const types: TypenameMap = {
	"SPFReceived": {"Name":"SPFReceived","Docs":"","Fields":[{"Name":"Status","Docs":"","Typewords":["string"]},{"Name":"Mechanism","Docs":"","Typewords":["string"]}]},
	"Domain": {"Name":"Domain","Docs":"","Fields":[{"Name":"ASCII","Docs":"","Typewords":["string"]},{"Name":"Unicode","Docs":"","Typewords":["string"]}]},
	"Record": {"Name":"Record","Docs":"","Fields":[{"Name":"Version","Docs":"","Typewords":["string"]},{"Name":"Hashes","Docs":"","Typewords":["[]","string"]},{"Name":"Key","Docs":"","Typewords":["string"]},{"Name":"Notes","Docs":"","Typewords":["string"]},{"Name":"Pubkey","Docs":"","Typewords":["nullable","string"]},{"Name":"Services","Docs":"","Typewords":["[]","string"]},{"Name":"Flags","Docs":"","Typewords":["[]","string"]}]},
	"DKIMResult": {"Name":"DKIMResult","Docs":"","Fields":[{"Name":"Status","Docs":"","Typewords":["DKIMStatus"]},{"Name":"Sig","Docs":"","Typewords":["nullable","Sig"]},{"Name":"Record","Docs":"","Typewords":["nullable","Record"]},{"Name":"RecordAuthentic","Docs":"","Typewords":["bool"]},{"Name":"Error","Docs":"","Typewords":["string"]}]},
	"Sig": {"Name":"Sig","Docs":"","Fields":[{"Name":"Version","Docs":"","Typewords":["int32"]},{"Name":"AlgorithmSign","Docs":"","Typewords":["string"]},{"Name":"AlgorithmHash","Docs":"","Typewords":["string"]},{"Name":"Signature","Docs":"","Typewords":["nullable","string"]},{"Name":"BodyHash","Docs":"","Typewords":["nullable","string"]},{"Name":"Domain","Docs":"","Typewords":["Domain"]},{"Name":"SignedHeaders","Docs":"","Typewords":["[]","string"]},{"Name":"Selector","Docs":"","Typewords":["Domain"]},{"Name":"Canonicalization","Docs":"","Typewords":["string"]},{"Name":"Length","Docs":"","Typewords":["int64"]},{"Name":"Identity","Docs":"","Typewords":["nullable","Identity"]},{"Name":"QueryMethods","Docs":"","Typewords":["[]","string"]},{"Name":"SignTime","Docs":"","Typewords":["int64"]},{"Name":"ExpireTime","Docs":"","Typewords":["int64"]},{"Name":"CopiedHeaders","Docs":"","Typewords":["[]","string"]}]},
	"Identity": {"Name":"Identity","Docs":"","Fields":[{"Name":"Localpart","Docs":"","Typewords":["nullable","Localpart"]},{"Name":"Domain","Docs":"","Typewords":["Domain"]}]},
	"DomainResult": {"Name":"DomainResult","Docs":"","Fields":[{"Name":"DurationMS","Docs":"","Typewords":["int32"]},{"Name":"Domain","Docs":"","Typewords":["Domain"]},{"Name":"SPF","Docs":"","Typewords":["DomainSPF"]},{"Name":"DMARC","Docs":"","Typewords":["DomainDMARC"]},{"Name":"TLSRPT","Docs":"","Typewords":["DomainTLSRPT"]},{"Name":"MTASTS","Docs":"","Typewords":["DomainMTASTS"]},{"Name":"MX","Docs":"","Typewords":["DomainMX"]},{"Name":"MXHosts","Docs":"","Typewords":["[]","DomainMXHost"]}]},
	"DomainSPF": {"Name":"DomainSPF","Docs":"","Fields":[{"Name":"DurationMS","Docs":"","Typewords":["int32"]},{"Name":"Status","Docs":"","Typewords":["string"]},{"Name":"TXT","Docs":"","Typewords":["string"]},{"Name":"Record","Docs":"","Typewords":["nullable","SPFRecord"]},{"Name":"Authentic","Docs":"","Typewords":["bool"]},{"Name":"Error","Docs":"","Typewords":["string"]}]},
	"SPFRecord": {"Name":"SPFRecord","Docs":"","Fields":[{"Name":"Version","Docs":"","Typewords":["string"]},{"Name":"Directives","Docs":"","Typewords":["[]","Directive"]},{"Name":"Redirect","Docs":"","Typewords":["string"]},{"Name":"Explanation","Docs":"","Typewords":["string"]},{"Name":"Other","Docs":"","Typewords":["[]","Modifier"]}]},
	"Directive": {"Name":"Directive","Docs":"","Fields":[{"Name":"Qualifier","Docs":"","Typewords":["string"]},{"Name":"Mechanism","Docs":"","Typewords":["string"]},{"Name":"DomainSpec","Docs":"","Typewords":["string"]},{"Name":"IPstr","Docs":"","Typewords":["string"]},{"Name":"IP4CIDRLen","Docs":"","Typewords":["nullable","int32"]},{"Name":"IP6CIDRLen","Docs":"","Typewords":["nullable","int32"]}]},
	"Modifier": {"Name":"Modifier","Docs":"","Fields":[{"Name":"Key","Docs":"","Typewords":["string"]},{"Name":"Value","Docs":"","Typewords":["string"]}]},
	"DomainDMARC": {"Name":"DomainDMARC","Docs":"","Fields":[{"Name":"DurationMS","Docs":"","Typewords":["int32"]},{"Name":"Status","Docs":"","Typewords":["string"]},{"Name":"Domain","Docs":"","Typewords":["Domain"]},{"Name":"Record","Docs":"","Typewords":["nullable","DMARCRecord"]},{"Name":"TXT","Docs":"","Typewords":["string"]},{"Name":"Authentic","Docs":"","Typewords":["bool"]},{"Name":"Error","Docs":"","Typewords":["string"]}]},
	"DMARCRecord": {"Name":"DMARCRecord","Docs":"","Fields":[{"Name":"Version","Docs":"","Typewords":["string"]},{"Name":"Policy","Docs":"","Typewords":["DMARCPolicy"]},{"Name":"SubdomainPolicy","Docs":"","Typewords":["DMARCPolicy"]},{"Name":"AggregateReportAddresses","Docs":"","Typewords":["[]","URI"]},{"Name":"FailureReportAddresses","Docs":"","Typewords":["[]","URI"]},{"Name":"ADKIM","Docs":"","Typewords":["Align"]},{"Name":"ASPF","Docs":"","Typewords":["Align"]},{"Name":"AggregateReportingInterval","Docs":"","Typewords":["int32"]},{"Name":"FailureReportingOptions","Docs":"","Typewords":["[]","string"]},{"Name":"ReportingFormat","Docs":"","Typewords":["[]","string"]},{"Name":"Percentage","Docs":"","Typewords":["int32"]}]},
	"URI": {"Name":"URI","Docs":"","Fields":[{"Name":"Address","Docs":"","Typewords":["string"]},{"Name":"MaxSize","Docs":"","Typewords":["uint64"]},{"Name":"Unit","Docs":"","Typewords":["string"]}]},
	"DomainTLSRPT": {"Name":"DomainTLSRPT","Docs":"","Fields":[{"Name":"DurationMS","Docs":"","Typewords":["int32"]},{"Name":"Record","Docs":"","Typewords":["nullable","TLSRPTRecord"]},{"Name":"TXT","Docs":"","Typewords":["string"]},{"Name":"Error","Docs":"","Typewords":["string"]}]},
	"TLSRPTRecord": {"Name":"TLSRPTRecord","Docs":"","Fields":[{"Name":"Version","Docs":"","Typewords":["string"]},{"Name":"RUAs","Docs":"","Typewords":["[]","[]","RUA"]},{"Name":"Extensions","Docs":"","Typewords":["[]","Extension"]}]},
	"Extension": {"Name":"Extension","Docs":"","Fields":[{"Name":"Key","Docs":"","Typewords":["string"]},{"Name":"Value","Docs":"","Typewords":["string"]}]},
	"DomainMTASTS": {"Name":"DomainMTASTS","Docs":"","Fields":[{"Name":"DurationMS","Docs":"","Typewords":["int32"]},{"Name":"Implemented","Docs":"","Typewords":["bool"]},{"Name":"Record","Docs":"","Typewords":["nullable","MTASTSRecord"]},{"Name":"Policy","Docs":"","Typewords":["nullable","Policy"]},{"Name":"PolicyText","Docs":"","Typewords":["string"]},{"Name":"Error","Docs":"","Typewords":["string"]}]},
	"MTASTSRecord": {"Name":"MTASTSRecord","Docs":"","Fields":[{"Name":"Version","Docs":"","Typewords":["string"]},{"Name":"ID","Docs":"","Typewords":["string"]},{"Name":"Extensions","Docs":"","Typewords":["[]","Pair"]}]},
	"Pair": {"Name":"Pair","Docs":"","Fields":[{"Name":"Key","Docs":"","Typewords":["string"]},{"Name":"Value","Docs":"","Typewords":["string"]}]},
	"Policy": {"Name":"Policy","Docs":"","Fields":[{"Name":"Version","Docs":"","Typewords":["string"]},{"Name":"Mode","Docs":"","Typewords":["Mode"]},{"Name":"MX","Docs":"","Typewords":["[]","STSMX"]},{"Name":"MaxAgeSeconds","Docs":"","Typewords":["int32"]},{"Name":"Extensions","Docs":"","Typewords":["[]","Pair"]}]},
	"STSMX": {"Name":"STSMX","Docs":"","Fields":[{"Name":"Wildcard","Docs":"","Typewords":["bool"]},{"Name":"Domain","Docs":"","Typewords":["Domain"]}]},
	"DomainMX": {"Name":"DomainMX","Docs":"","Fields":[{"Name":"DurationMS","Docs":"","Typewords":["int32"]},{"Name":"Have","Docs":"","Typewords":["bool"]},{"Name":"OrigNextHopAuthentic","Docs":"","Typewords":["bool"]},{"Name":"ExpandedNextHopAuthentic","Docs":"","Typewords":["bool"]},{"Name":"ExpandedNextHop","Docs":"","Typewords":["Domain"]},{"Name":"Permanent","Docs":"","Typewords":["bool"]},{"Name":"Error","Docs":"","Typewords":["string"]}]},
	"DomainMXHost": {"Name":"DomainMXHost","Docs":"","Fields":[{"Name":"DurationMS","Docs":"","Typewords":["int32"]},{"Name":"Host","Docs":"","Typewords":["IPDomain"]},{"Name":"MTASTSError","Docs":"","Typewords":["string"]},{"Name":"IP","Docs":"","Typewords":["DomainIP"]},{"Name":"DANE","Docs":"","Typewords":["DomainDANE"]},{"Name":"Dial","Docs":"","Typewords":["DomainDial"]},{"Name":"SMTP","Docs":"","Typewords":["DomainSMTP"]}]},
	"IPDomain": {"Name":"IPDomain","Docs":"","Fields":[{"Name":"IP","Docs":"","Typewords":["IP"]},{"Name":"Domain","Docs":"","Typewords":["Domain"]}]},
	"DomainIP": {"Name":"DomainIP","Docs":"","Fields":[{"Name":"DurationMS","Docs":"","Typewords":["int32"]},{"Name":"Authentic","Docs":"","Typewords":["bool"]},{"Name":"ExpandedAuthentic","Docs":"","Typewords":["bool"]},{"Name":"ExpandedHost","Docs":"","Typewords":["Domain"]},{"Name":"IPs","Docs":"","Typewords":["[]","IP"]},{"Name":"DualStack","Docs":"","Typewords":["bool"]},{"Name":"Error","Docs":"","Typewords":["string"]}]},
	"DomainDANE": {"Name":"DomainDANE","Docs":"","Fields":[{"Name":"DurationMS","Docs":"","Typewords":["int32"]},{"Name":"Required","Docs":"","Typewords":["bool"]},{"Name":"Records","Docs":"","Typewords":["[]","TLSARecord"]},{"Name":"TLSABaseDomain","Docs":"","Typewords":["Domain"]},{"Name":"Error","Docs":"","Typewords":["string"]},{"Name":"VerifiedRecord","Docs":"","Typewords":["TLSARecord"]}]},
	"TLSARecord": {"Name":"TLSARecord","Docs":"","Fields":[{"Name":"Usage","Docs":"","Typewords":["TLSAUsage"]},{"Name":"Selector","Docs":"","Typewords":["TLSASelector"]},{"Name":"MatchType","Docs":"","Typewords":["TLSAMatchType"]},{"Name":"CertAssoc","Docs":"","Typewords":["nullable","string"]}]},
	"DomainDial": {"Name":"DomainDial","Docs":"","Fields":[{"Name":"DurationMS","Docs":"","Typewords":["int32"]},{"Name":"IP","Docs":"","Typewords":["IP"]},{"Name":"Error","Docs":"","Typewords":["string"]}]},
	"DomainSMTP": {"Name":"DomainSMTP","Docs":"","Fields":[{"Name":"DurationMS","Docs":"","Typewords":["int32"]},{"Name":"Error","Docs":"","Typewords":["string"]},{"Name":"Supports8bitMIME","Docs":"","Typewords":["bool"]},{"Name":"SupportsRequireTLS","Docs":"","Typewords":["bool"]},{"Name":"SupportsSMTPUTF8","Docs":"","Typewords":["bool"]},{"Name":"SupportsSTARTTLS","Docs":"","Typewords":["bool"]},{"Name":"TLSConnectionState","Docs":"","Typewords":["nullable","TLSConnectionState"]},{"Name":"RecipientDomainResult","Docs":"","Typewords":["nullable","TLSRPTResult"]},{"Name":"HostResult","Docs":"","Typewords":["nullable","TLSRPTResult"]},{"Name":"Trace","Docs":"","Typewords":["[]","Proto"]}]},
	"TLSConnectionState": {"Name":"TLSConnectionState","Docs":"","Fields":[{"Name":"Version","Docs":"","Typewords":["string"]},{"Name":"CipherSuite","Docs":"","Typewords":["string"]},{"Name":"NegotiatedProtocol","Docs":"","Typewords":["string"]},{"Name":"ServerName","Docs":"","Typewords":["string"]}]},
	"TLSRPTResult": {"Name":"TLSRPTResult","Docs":"","Fields":[{"Name":"Policy","Docs":"","Typewords":["TLSRPTResultPolicy"]},{"Name":"Summary","Docs":"","Typewords":["TLSRPTSummary"]},{"Name":"FailureDetails","Docs":"","Typewords":["[]","TLSRPTFailureDetails"]}]},
	"TLSRPTResultPolicy": {"Name":"TLSRPTResultPolicy","Docs":"","Fields":[{"Name":"Type","Docs":"","Typewords":["string"]},{"Name":"String","Docs":"","Typewords":["[]","string"]},{"Name":"Domain","Docs":"","Typewords":["string"]},{"Name":"MXHost","Docs":"","Typewords":["[]","string"]}]},
	"TLSRPTSummary": {"Name":"TLSRPTSummary","Docs":"","Fields":[{"Name":"TotalSuccessfulSessionCount","Docs":"","Typewords":["int64"]},{"Name":"TotalFailureSessionCount","Docs":"","Typewords":["int64"]}]},
	"TLSRPTFailureDetails": {"Name":"TLSRPTFailureDetails","Docs":"","Fields":[{"Name":"ResultType","Docs":"","Typewords":["string"]},{"Name":"SendingMTAIP","Docs":"","Typewords":["string"]},{"Name":"ReceivingMXHostname","Docs":"","Typewords":["string"]},{"Name":"ReceivingMXHelo","Docs":"","Typewords":["string"]},{"Name":"ReceivingIP","Docs":"","Typewords":["string"]},{"Name":"FailedSessionCount","Docs":"","Typewords":["int64"]},{"Name":"AdditionalInformation","Docs":"","Typewords":["string"]},{"Name":"FailureReasonCode","Docs":"","Typewords":["string"]}]},
	"Proto": {"Name":"Proto","Docs":"","Fields":[{"Name":"ClientWrite","Docs":"","Typewords":["bool"]},{"Name":"Text","Docs":"","Typewords":["string"]}]},
	"TLSAUsage": {"Name":"TLSAUsage","Docs":"","Values":[{"Name":"TLSAUsagePKIXTA","Value":0,"Docs":""},{"Name":"TLSAUsagePKIXEE","Value":1,"Docs":""},{"Name":"TLSAUsageDANETA","Value":2,"Docs":""},{"Name":"TLSAUsageDANEEE","Value":3,"Docs":""}]},
	"TLSASelector": {"Name":"TLSASelector","Docs":"","Values":[{"Name":"TLSASelectorCert","Value":0,"Docs":""},{"Name":"TLSASelectorSPKI","Value":1,"Docs":""}]},
	"TLSAMatchType": {"Name":"TLSAMatchType","Docs":"","Values":[{"Name":"TLSAMatchTypeFull","Value":0,"Docs":""},{"Name":"TLSAMatchTypeSHA256","Value":1,"Docs":""},{"Name":"TLSAMatchTypeSHA512","Value":2,"Docs":""}]},
	"DKIMStatus": {"Name":"DKIMStatus","Docs":"","Values":null},
	"Localpart": {"Name":"Localpart","Docs":"","Values":null},
	"DMARCPolicy": {"Name":"DMARCPolicy","Docs":"","Values":[{"Name":"PolicyEmpty","Value":"","Docs":""},{"Name":"PolicyNone","Value":"none","Docs":""},{"Name":"PolicyQuarantine","Value":"quarantine","Docs":""},{"Name":"PolicyReject","Value":"reject","Docs":""}]},
	"Align": {"Name":"Align","Docs":"","Values":[{"Name":"AlignStrict","Value":"s","Docs":""},{"Name":"AlignRelaxed","Value":"r","Docs":""}]},
	"RUA": {"Name":"RUA","Docs":"","Values":null},
	"Mode": {"Name":"Mode","Docs":"","Values":[{"Name":"ModeEnforce","Value":"enforce","Docs":""},{"Name":"ModeTesting","Value":"testing","Docs":""},{"Name":"ModeNone","Value":"none","Docs":""}]},
	"IP": {"Name":"IP","Docs":"","Values":[]},
}

export const parser = {
	SPFReceived: (v: any) => parse("SPFReceived", v) as SPFReceived,
	Domain: (v: any) => parse("Domain", v) as Domain,
	Record: (v: any) => parse("Record", v) as Record,
	DKIMResult: (v: any) => parse("DKIMResult", v) as DKIMResult,
	Sig: (v: any) => parse("Sig", v) as Sig,
	Identity: (v: any) => parse("Identity", v) as Identity,
	DomainResult: (v: any) => parse("DomainResult", v) as DomainResult,
	DomainSPF: (v: any) => parse("DomainSPF", v) as DomainSPF,
	SPFRecord: (v: any) => parse("SPFRecord", v) as SPFRecord,
	Directive: (v: any) => parse("Directive", v) as Directive,
	Modifier: (v: any) => parse("Modifier", v) as Modifier,
	DomainDMARC: (v: any) => parse("DomainDMARC", v) as DomainDMARC,
	DMARCRecord: (v: any) => parse("DMARCRecord", v) as DMARCRecord,
	URI: (v: any) => parse("URI", v) as URI,
	DomainTLSRPT: (v: any) => parse("DomainTLSRPT", v) as DomainTLSRPT,
	TLSRPTRecord: (v: any) => parse("TLSRPTRecord", v) as TLSRPTRecord,
	Extension: (v: any) => parse("Extension", v) as Extension,
	DomainMTASTS: (v: any) => parse("DomainMTASTS", v) as DomainMTASTS,
	MTASTSRecord: (v: any) => parse("MTASTSRecord", v) as MTASTSRecord,
	Pair: (v: any) => parse("Pair", v) as Pair,
	Policy: (v: any) => parse("Policy", v) as Policy,
	STSMX: (v: any) => parse("STSMX", v) as STSMX,
	DomainMX: (v: any) => parse("DomainMX", v) as DomainMX,
	DomainMXHost: (v: any) => parse("DomainMXHost", v) as DomainMXHost,
	IPDomain: (v: any) => parse("IPDomain", v) as IPDomain,
	DomainIP: (v: any) => parse("DomainIP", v) as DomainIP,
	DomainDANE: (v: any) => parse("DomainDANE", v) as DomainDANE,
	TLSARecord: (v: any) => parse("TLSARecord", v) as TLSARecord,
	DomainDial: (v: any) => parse("DomainDial", v) as DomainDial,
	DomainSMTP: (v: any) => parse("DomainSMTP", v) as DomainSMTP,
	TLSConnectionState: (v: any) => parse("TLSConnectionState", v) as TLSConnectionState,
	TLSRPTResult: (v: any) => parse("TLSRPTResult", v) as TLSRPTResult,
	TLSRPTResultPolicy: (v: any) => parse("TLSRPTResultPolicy", v) as TLSRPTResultPolicy,
	TLSRPTSummary: (v: any) => parse("TLSRPTSummary", v) as TLSRPTSummary,
	TLSRPTFailureDetails: (v: any) => parse("TLSRPTFailureDetails", v) as TLSRPTFailureDetails,
	Proto: (v: any) => parse("Proto", v) as Proto,
	TLSAUsage: (v: any) => parse("TLSAUsage", v) as TLSAUsage,
	TLSASelector: (v: any) => parse("TLSASelector", v) as TLSASelector,
	TLSAMatchType: (v: any) => parse("TLSAMatchType", v) as TLSAMatchType,
	DKIMStatus: (v: any) => parse("DKIMStatus", v) as DKIMStatus,
	Localpart: (v: any) => parse("Localpart", v) as Localpart,
	DMARCPolicy: (v: any) => parse("DMARCPolicy", v) as DMARCPolicy,
	Align: (v: any) => parse("Align", v) as Align,
	RUA: (v: any) => parse("RUA", v) as RUA,
	Mode: (v: any) => parse("Mode", v) as Mode,
	IP: (v: any) => parse("IP", v) as IP,
}

let defaultOptions: ClientOptions = {slicesNullable: true, mapsNullable: true, nullableOptional: true}

export class Client {
	constructor(private baseURL=defaultBaseURL, public options?: ClientOptions) {
		if (!options) {
			this.options = defaultOptions
		}
	}

	withOptions(options: ClientOptions): Client {
		return new Client(this.baseURL, { ...this.options, ...options })
	}

	async SPFCheck(domain: string, ipstr: string): Promise<[SPFReceived, Domain, string, boolean]> {
		const fn: string = "SPFCheck"
		const paramTypes: string[][] = [["string"],["string"]]
		const returnTypes: string[][] = [["SPFReceived"],["Domain"],["string"],["bool"]]
		const params: any[] = [domain, ipstr]
		return await _sherpaCall(this.baseURL, { ...this.options }, paramTypes, returnTypes, fn, params) as [SPFReceived, Domain, string, boolean]
	}

	async DKIMLookup(selector: string, domain: string): Promise<[DKIMStatus, Record | null, string, boolean]> {
		const fn: string = "DKIMLookup"
		const paramTypes: string[][] = [["string"],["string"]]
		const returnTypes: string[][] = [["DKIMStatus"],["nullable","Record"],["string"],["bool"]]
		const params: any[] = [selector, domain]
		return await _sherpaCall(this.baseURL, { ...this.options }, paramTypes, returnTypes, fn, params) as [DKIMStatus, Record | null, string, boolean]
	}

	async DKIMVerify(message: string): Promise<DKIMResult[] | null> {
		const fn: string = "DKIMVerify"
		const paramTypes: string[][] = [["string"]]
		const returnTypes: string[][] = [["[]","DKIMResult"]]
		const params: any[] = [message]
		return await _sherpaCall(this.baseURL, { ...this.options }, paramTypes, returnTypes, fn, params) as DKIMResult[] | null
	}

	async DomainCheck(domain: string): Promise<DomainResult> {
		const fn: string = "DomainCheck"
		const paramTypes: string[][] = [["string"]]
		const returnTypes: string[][] = [["DomainResult"]]
		const params: any[] = [domain]
		return await _sherpaCall(this.baseURL, { ...this.options }, paramTypes, returnTypes, fn, params) as DomainResult
	}
}

export const defaultBaseURL = (function() {
	let p = location.pathname
	if (p && p[p.length - 1] !== '/') {
		let l = location.pathname.split('/')
		l = l.slice(0, l.length - 1)
		p = '/' + l.join('/') + '/'
	}
	return location.protocol + '//' + location.host + p + 'api/'
})()

// NOTE: code below is shared between github.com/mjl-/sherpaweb and github.com/mjl-/sherpats.
// KEEP IN SYNC.

export const supportedSherpaVersion = 1

export interface Section {
	Name: string
	Docs: string
	Functions: Function[]
	Sections: Section[]
	Structs: Struct[]
	Ints: Ints[]
	Strings: Strings[]
	Version: string // only for top-level section
	SherpaVersion: number // only for top-level section
	SherpadocVersion: number // only for top-level section
}

export interface Function {
	Name: string
	Docs: string
	Params: Arg[]
	Returns: Arg[]
}

export interface Arg {
	Name: string
	Typewords: string[]
}

export interface Struct {
	Name: string
	Docs: string
	Fields: Field[]
}

export interface Field {
	Name: string
	Docs: string
	Typewords: string[]
}

export interface Ints {
	Name: string
	Docs: string
	Values: {
		Name: string
		Value: number
		Docs: string
	}[] | null
}

export interface Strings {
	Name: string
	Docs: string
	Values: {
		Name: string
		Value: string
		Docs: string
	}[] | null
}

export type NamedType = Struct | Strings | Ints
export type TypenameMap = { [k: string]: NamedType }

// verifyArg typechecks "v" against "typewords", returning a new (possibly modified) value for JSON-encoding.
// toJS indicate if the data is coming into JS. If so, timestamps are turned into JS Dates. Otherwise, JS Dates are turned into strings.
// allowUnknownKeys configures whether unknown keys in structs are allowed.
// types are the named types of the API.
export const verifyArg = (path: string, v: any, typewords: string[], toJS: boolean, allowUnknownKeys: boolean, types: TypenameMap, opts: ClientOptions): any => {
	return new verifier(types, toJS, allowUnknownKeys, opts).verify(path, v, typewords)
}

export const parse = (name: string, v: any): any => verifyArg(name, v, [name], true, false, types, defaultOptions)

class verifier {
	constructor(private types: TypenameMap, private toJS: boolean, private allowUnknownKeys: boolean, private opts: ClientOptions) {
	}

	verify(path: string, v: any, typewords: string[]): any {
		typewords = typewords.slice(0)
		const ww = typewords.shift()

		const error = (msg: string) => {
			if (path != '') {
				msg = path + ': ' + msg
			}
			throw new Error(msg)
		}

		if (typeof ww !== 'string') {
			error('bad typewords')
			return // should not be necessary, typescript doesn't see error always throws an exception?
		}
		const w: string = ww

		const ensure = (ok: boolean, expect: string): any => {
			if (!ok) {
				error('got ' + JSON.stringify(v) +  ', expected ' + expect)
			}
			return v
		}

		switch (w) {
		case 'nullable':
			if (v === null || v === undefined && this.opts.nullableOptional) {
				return v
			}
			return this.verify(path, v, typewords)
		case '[]':
			if (v === null && this.opts.slicesNullable || v === undefined && this.opts.slicesNullable && this.opts.nullableOptional) {
				return v
			}
			ensure(Array.isArray(v), "array")
			return v.map((e: any, i: number) => this.verify(path + '[' + i + ']', e, typewords))
		case '{}':
			if (v === null && this.opts.mapsNullable || v === undefined && this.opts.mapsNullable && this.opts.nullableOptional) {
				return v
			}
			ensure(v !== null || typeof v === 'object', "object")
			const r: any = {}
			for (const k in v) {
				r[k] = this.verify(path + '.' + k, v[k], typewords)
			}
			return r
		}

		ensure(typewords.length == 0, "empty typewords")
		const t = typeof v
		switch (w) {
		case 'any':
			return v
		case 'bool':
			ensure(t === 'boolean', 'bool')
			return v
		case 'int8':
		case 'uint8':
		case 'int16':
		case 'uint16':
		case 'int32':
		case 'uint32':
		case 'int64':
		case 'uint64':
			ensure(t === 'number' && Number.isInteger(v), 'integer')
			return v
		case 'float32':
		case 'float64':
			ensure(t === 'number', 'float')
			return v
		case 'int64s':
		case 'uint64s':
			ensure(t === 'number' && Number.isInteger(v) || t === 'string', 'integer fitting in float without precision loss, or string')
			return '' + v
		case 'string':
			ensure(t === 'string', 'string')
			return v
		case 'timestamp':
			if (this.toJS) {
				ensure(t === 'string', 'string, with timestamp')
				const d = new Date(v)
				if (d instanceof Date && !isNaN(d.getTime())) {
					return d
				}
				error('invalid date ' + v)
			} else {
				ensure(t === 'object' && v !== null, 'non-null object')
				ensure(v.__proto__ === Date.prototype, 'Date')
				return v.toISOString()
			}
		}

		// We're left with named types.
		const nt = this.types[w]
		if (!nt) {
			error('unknown type ' + w)
		}
		if (v === null) {
			error('bad value ' + v + ' for named type ' + w)
		}

		if (structTypes[nt.Name]) {
			const t = nt as Struct
			if (typeof v !== 'object') {
				error('bad value ' + v + ' for struct ' + w)
			}

			const r: any = {}
			for (const f of t.Fields) {
				r[f.Name] = this.verify(path + '.' + f.Name, v[f.Name], f.Typewords)
			}
			// If going to JSON also verify no unknown fields are present.
			if (!this.allowUnknownKeys) {
				const known: { [key: string]: boolean } = {}
				for (const f of t.Fields) {
					known[f.Name] = true
				}
				Object.keys(v).forEach((k) => {
					if (!known[k]) {
						error('unknown key ' + k + ' for struct ' + w)
					}
				})
			}
			return r
		} else if (stringsTypes[nt.Name]) {
			const t = nt as Strings
			if (typeof v !== 'string') {
				error('mistyped value ' + v + ' for named strings ' + t.Name)
			}
			if (!t.Values || t.Values.length === 0) {
				return v
			}
			for (const sv of t.Values) {
				if (sv.Value === v) {
					return v
				}
			}
			error('unknkown value ' + v + ' for named strings ' + t.Name)
		} else if (intsTypes[nt.Name]) {
			const t = nt as Ints
			if (typeof v !== 'number' || !Number.isInteger(v)) {
				error('mistyped value ' + v + ' for named ints ' + t.Name)
			}
			if (!t.Values || t.Values.length === 0) {
				return v
			}
			for (const sv of t.Values) {
				if (sv.Value === v) {
					return v
				}
			}
			error('unknkown value ' + v + ' for named ints ' + t.Name)
		} else {
			throw new Error('unexpected named type ' + nt)
		}
	}
}


export interface ClientOptions {
	aborter?: {abort?: () => void}
	timeoutMsec?: number
	skipParamCheck?: boolean
	skipReturnCheck?: boolean
	slicesNullable?: boolean
	mapsNullable?: boolean
	nullableOptional?: boolean
}

const _sherpaCall = async (baseURL: string, options: ClientOptions, paramTypes: string[][], returnTypes: string[][], name: string, params: any[]): Promise<any> => {
	if (!options.skipParamCheck) {
		if (params.length !== paramTypes.length) {
			return Promise.reject({ message: 'wrong number of parameters in sherpa call, saw ' + params.length + ' != expected ' + paramTypes.length })
		}
		params = params.map((v: any, index: number) => verifyArg('params[' + index + ']', v, paramTypes[index], false, false, types, options))
	}
	const simulate = async (json: string) => {
		const config = JSON.parse(json || 'null') || {}
		const waitMinMsec = config.waitMinMsec || 0
		const waitMaxMsec = config.waitMaxMsec || 0
		const wait = Math.random() * (waitMaxMsec - waitMinMsec)
		const failRate = config.failRate || 0
		return new Promise<void>((resolve, reject) => {
			if (options.aborter) {
				options.aborter.abort = () => {
					reject({ message: 'call to ' + name + ' aborted by user', code: 'sherpa:aborted' })
					reject = resolve = () => { }
				}
			}
			setTimeout(() => {
				const r = Math.random()
				if (r < failRate) {
					reject({ message: 'injected failure on ' + name, code: 'server:injected' })
				} else {
					resolve()
				}
				reject = resolve = () => { }
			}, waitMinMsec + wait)
		})
	}
	// Only simulate when there is a debug string. Otherwise it would always interfere
	// with setting options.aborter.
	let json: string = ''
	try {
		json = window.localStorage.getItem('sherpats-debug') || ''
	} catch (err) {}
	if (json) {
		await simulate(json)
	}

	// Immediately create promise, so options.aborter is changed before returning.
	const promise = new Promise((resolve, reject) => {
		let resolve1 = (v: { code: string, message: string }) => {
			resolve(v)
			resolve1 = () => { }
			reject1 = () => { }
		}
		let reject1 = (v: { code: string, message: string }) => {
			reject(v)
			resolve1 = () => { }
			reject1 = () => { }
		}

		const url = baseURL + name
		const req = new window.XMLHttpRequest()
		if (options.aborter) {
			options.aborter.abort = () => {
				req.abort()
				reject1({ code: 'sherpa:aborted', message: 'request aborted' })
			}
		}
		req.open('POST', url, true)
		if (options.timeoutMsec) {
			req.timeout = options.timeoutMsec
		}
		req.onload = () => {
			if (req.status !== 200) {
				if (req.status === 404) {
					reject1({ code: 'sherpa:badFunction', message: 'function does not exist' })
				} else {
					reject1({ code: 'sherpa:http', message: 'error calling function, HTTP status: ' + req.status })
				}
				return
			}

			let resp: any
			try {
				resp = JSON.parse(req.responseText)
			} catch (err) {
				reject1({ code: 'sherpa:badResponse', message: 'bad JSON from server' })
				return
			}
			if (resp && resp.error) {
				const err = resp.error
				reject1({ code: err.code, message: err.message })
				return
			} else if (!resp || !resp.hasOwnProperty('result')) {
				reject1({ code: 'sherpa:badResponse', message: "invalid sherpa response object, missing 'result'" })
				return
			}

			if (options.skipReturnCheck) {
				resolve1(resp.result)
				return
			}
			let result = resp.result
			try {
				if (returnTypes.length === 0) {
					if (result) {
						throw new Error('function ' + name + ' returned a value while prototype says it returns "void"')
					}
				} else if (returnTypes.length === 1) {
					result = verifyArg('result', result, returnTypes[0], true, true, types, options)
				} else {
					if (result.length != returnTypes.length) {
						throw new Error('wrong number of values returned by ' + name + ', saw ' + result.length + ' != expected ' + returnTypes.length)
					}
					result = result.map((v: any, index: number) => verifyArg('result[' + index + ']', v, returnTypes[index], true, true, types, options))
				}
			} catch (err) {
				let errmsg = 'bad types'
				if (err instanceof Error) {
					errmsg = err.message
				}
				reject1({ code: 'sherpa:badTypes', message: errmsg })
			}
			resolve1(result)
		}
		req.onerror = () => {
			reject1({ code: 'sherpa:connection', message: 'connection failed' })
		}
		req.ontimeout = () => {
			reject1({ code: 'sherpa:timeout', message: 'request timeout' })
		}
		req.setRequestHeader('Content-Type', 'application/json')
		try {
			req.send(JSON.stringify({ params: params }))
		} catch (err) {
			reject1({ code: 'sherpa:badData', message: 'cannot marshal to JSON' })
		}
	})
	return await promise
}

}
